package io.objects.tl.api;

import io.github.classgraph.ClassGraph;
import io.github.classgraph.ClassInfo;
import io.github.classgraph.ScanResult;
import io.objects.tl.TLContext;
import io.objects.tl.api.help.TLGetTermsOfServiceUpdate;
import io.objects.tl.core.*;
import io.objects.tl.mtproto.tl.MTInvokeAfter;
import io.objects.tl.mtproto.tl.MTMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Modifier;
import java.util.HashMap;

/**
 * This class is generated by Mono's TL class generator
 */
@SuppressWarnings("unused")
public class TLApiContext extends TLContext {
    private final static Logger logger = LoggerFactory.getLogger(TLApiContext.class);
    private static TLApiContext instance;

    protected TLApiContext() {
        super(665);
    }

    public static TLApiContext getInstance() {
        if (instance == null)
            instance = new TLApiContext();

        return instance;
    }

    protected String[] getPackages() {
        return new String[]{"io.objects.tl"};
    }

    protected <T extends TLObject> boolean classPredicate(Class<T> clazz) {
        return true;
    }

    @Override
    public void init() {
        HashMap<Integer, Class<? extends TLObject>> map = new HashMap<>();

        try (ScanResult scanResult = new ClassGraph()
                // .verbose()
                // .enableAllInfo()
                .whitelistPackages(getPackages())
                .ignoreMethodVisibility()
                .ignoreParentClassLoaders()
                .ignoreClassVisibility()
                .ignoreParentModuleLayers()
                .ignoreFieldVisibility()
                .scan()) {

            for (ClassInfo info : scanResult.getSubclasses("io.objects.tl.core.TLObject")) {
                Class<? extends TLObject> tlClass = (Class<? extends TLObject>) info.loadClass();

                if (Modifier.isAbstract(tlClass.getModifiers()) ||
                        TLBool.class.isAssignableFrom(tlClass)
                        || tlClass == MTInvokeAfter.class
                        || tlClass == TLGetTermsOfServiceUpdate.class
                        || tlClass == MTMessage.class
                        || tlClass == TLIntVector.class
                        || tlClass == TLLongVector.class
                        || tlClass == TLStringVector.class)
                    continue;

                if (!classPredicate(tlClass))
                    continue;

                int constructorId;
                try {
                    constructorId = tlClass.newInstance().getConstructorId();
                    if (map.containsKey(constructorId))
                        throw new IllegalStateException(String.format("TLObject %s has the same constructorId as %s.", tlClass.getName(), map.get(constructorId).getName()));
                    else
                        map.put(constructorId, tlClass);

                    registerClass(constructorId, tlClass);
                } catch (IllegalStateException e) {
                    logger.error("Error in registering TLObject {}. {}", tlClass.getSimpleName(), e.getMessage());
                    throw e;
                } catch (Exception e) {
                    logger.error("TLObject {} cannot be instantiated or its default constructor is not accessible.", tlClass.getSimpleName());
                    throw new IllegalStateException(String.format("TLObject %s cannot be instantiated or its default constructor is not accessible.", tlClass.getSimpleName()));
                }
            }

            logger.info("{} TLObjects registered in TLContext.", getSize());
        }
    }
}
